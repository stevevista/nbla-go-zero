// Copyright (c) 2017 Sony Corporation. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *WARNING*
// THIS FILE IS AUTO-GENERATED BY CODE GENERATOR.
// PLEASE DO NOT EDIT THIS FILE BY HAND!
// If you want to modify this file, edit following files.
// - build-tools/code_generator/templates/src_nbla_init_cpp_template.cpp
// - build-tools/code_generator/generator/generate_src_nbla_init_cpp.py


#include <nbla/cpu.hpp>
#include <nbla/array_registry.hpp>
#include <nbla/array/cpu_array.hpp>
#include <nbla/function_registry.hpp>
#include <nbla/function/affine.hpp>
#include <nbla/function/convolution.hpp>
#include <nbla/function/deconvolution.hpp>
#include <nbla/function/max_pooling.hpp>
#include <nbla/function/average_pooling.hpp>
#include <nbla/function/sum_pooling.hpp>
#include <nbla/function/unpooling.hpp>
#include <nbla/function/embed.hpp>
#include <nbla/function/sigmoid.hpp>
#include <nbla/function/swish.hpp>
#include <nbla/function/tanh.hpp>
#include <nbla/function/relu.hpp>
#include <nbla/function/leaky_relu.hpp>
#include <nbla/function/softmax.hpp>
#include <nbla/function/elu.hpp>
#include <nbla/function/selu.hpp>
#include <nbla/function/crelu.hpp>
#include <nbla/function/celu.hpp>
#include <nbla/function/prelu.hpp>
#include <nbla/function/batch_normalization.hpp>
#include <nbla/function/mean_subtraction.hpp>
#include <nbla/function/sum.hpp>
#include <nbla/function/mean.hpp>
#include <nbla/function/max.hpp>
#include <nbla/function/min.hpp>
#include <nbla/function/prod.hpp>
#include <nbla/function/reduce_sum.hpp>
#include <nbla/function/reduce_mean.hpp>
#include <nbla/function/add2.hpp>
#include <nbla/function/bc_add2.hpp>
#include <nbla/function/sub2.hpp>
#include <nbla/function/mul2.hpp>
#include <nbla/function/div2.hpp>
#include <nbla/function/pow2.hpp>
#include <nbla/function/add_scalar.hpp>
#include <nbla/function/mul_scalar.hpp>
#include <nbla/function/pow_scalar.hpp>
#include <nbla/function/r_sub_scalar.hpp>
#include <nbla/function/r_div_scalar.hpp>
#include <nbla/function/r_pow_scalar.hpp>
#include <nbla/function/sign.hpp>
#include <nbla/function/minimum2.hpp>
#include <nbla/function/maximum2.hpp>
#include <nbla/function/minimum_scalar.hpp>
#include <nbla/function/maximum_scalar.hpp>
#include <nbla/function/logical_and.hpp>
#include <nbla/function/logical_or.hpp>
#include <nbla/function/logical_xor.hpp>
#include <nbla/function/logical_and_scalar.hpp>
#include <nbla/function/logical_or_scalar.hpp>
#include <nbla/function/logical_xor_scalar.hpp>
#include <nbla/function/logical_not.hpp>
#include <nbla/function/constant.hpp>
#include <nbla/function/abs.hpp>
#include <nbla/function/exp.hpp>
#include <nbla/function/log.hpp>
#include <nbla/function/identity.hpp>
#include <nbla/function/batch_matmul.hpp>
#include <nbla/function/concatenate.hpp>
#include <nbla/function/split.hpp>
#include <nbla/function/stack.hpp>
#include <nbla/function/slice.hpp>
#include <nbla/function/transpose.hpp>
#include <nbla/function/broadcast.hpp>
#include <nbla/function/one_hot.hpp>
#include <nbla/function/flip.hpp>
#include <nbla/function/shift.hpp>
#include <nbla/function/reshape.hpp>
#include <nbla/function/matrix_diag.hpp>
#include <nbla/function/matrix_diag_part.hpp>
#include <nbla/function/dropout.hpp>
#include <nbla/function/rand.hpp>
#include <nbla/function/randint.hpp>
#include <nbla/function/randn.hpp>
#include <nbla/function/random_crop.hpp>
#include <nbla/function/random_flip.hpp>
#include <nbla/function/random_shift.hpp>
#include <nbla/function/sigmoid_cross_entropy.hpp>
#include <nbla/function/binary_cross_entropy.hpp>
#include <nbla/function/softmax_cross_entropy.hpp>
#include <nbla/function/categorical_cross_entropy.hpp>
#include <nbla/function/squared_error.hpp>
#include <nbla/function/absolute_error.hpp>
#include <nbla/function/kl_multinomial.hpp>
#include <nbla/function/unlink.hpp>
#include <nbla/function/sink.hpp>
#include <nbla/solver_registry.hpp>
#include <nbla/solver/adadelta.hpp>
#include <nbla/solver/adagrad.hpp>
#include <nbla/solver/adam.hpp>
#include <nbla/solver/adamax.hpp>
#include <nbla/solver/momentum.hpp>
#include <nbla/solver/nesterov.hpp>
#include <nbla/solver/rmsprop.hpp>
#include <nbla/solver/sgd.hpp>

namespace nbla {
void init_cpu() {
  static bool is_initialized = false;
  if (is_initialized)
    return;

  // Array registration
  NBLA_REGISTER_ARRAY_CREATOR(CpuArray);
  SingletonManager::get<Cpu>()->register_array_class("CpuArray");
  NBLA_REGISTER_ARRAY_CREATOR(CpuCachedArray);
  SingletonManager::get<Cpu>()->register_array_class("CpuCachedArray");
  NBLA_REGISTER_ARRAY_SYNCHRONIZER(CpuArray, CpuCachedArray,
                                   synchronizer_default);
  NBLA_REGISTER_ARRAY_SYNCHRONIZER(CpuCachedArray, CpuArray,
                                   synchronizer_default);

  // Function registration
  typedef Affine<float> Affinef;
  NBLA_REGISTER_FUNCTION_IMPL(Affine, Affinef, 0, "cpu", "default", int);
  typedef Convolution<float> Convolutionf;
  NBLA_REGISTER_FUNCTION_IMPL(Convolution, Convolutionf, 0, "cpu", "default", int, const vector<int> &, const vector<int> &, const vector<int> &, int);
  typedef Deconvolution<float> Deconvolutionf;
  NBLA_REGISTER_FUNCTION_IMPL(Deconvolution, Deconvolutionf, 0, "cpu", "default", int, const vector<int> &, const vector<int> &, const vector<int> &, int);
  typedef MaxPooling<float> MaxPoolingf;
  NBLA_REGISTER_FUNCTION_IMPL(MaxPooling, MaxPoolingf, 0, "cpu", "default", const vector<int> &, const vector<int> &, bool, const vector<int> &);
  typedef AveragePooling<float> AveragePoolingf;
  NBLA_REGISTER_FUNCTION_IMPL(AveragePooling, AveragePoolingf, 0, "cpu", "default", const vector<int> &, const vector<int> &, bool, const vector<int> &, bool);
  typedef SumPooling<float> SumPoolingf;
  NBLA_REGISTER_FUNCTION_IMPL(SumPooling, SumPoolingf, 0, "cpu", "default", const vector<int> &, const vector<int> &, bool, const vector<int> &);
  typedef Unpooling<float> Unpoolingf;
  NBLA_REGISTER_FUNCTION_IMPL(Unpooling, Unpoolingf, 0, "cpu", "default", const vector<int> &);
  typedef Embed<int, float> Embedif;
  NBLA_REGISTER_FUNCTION_IMPL(Embed, Embedif, 0, "cpu", "default");
  typedef Sigmoid<float> Sigmoidf;
  NBLA_REGISTER_FUNCTION_IMPL(Sigmoid, Sigmoidf, 0, "cpu", "default");
  typedef Swish<float> Swishf;
  NBLA_REGISTER_FUNCTION_IMPL(Swish, Swishf, 0, "cpu", "default");
  typedef Tanh<float> Tanhf;
  NBLA_REGISTER_FUNCTION_IMPL(Tanh, Tanhf, 0, "cpu", "default");
  typedef ReLU<float> ReLUf;
  NBLA_REGISTER_FUNCTION_IMPL(ReLU, ReLUf, 0, "cpu", "default", bool);
  typedef LeakyReLU<float> LeakyReLUf;
  NBLA_REGISTER_FUNCTION_IMPL(LeakyReLU, LeakyReLUf, 0, "cpu", "default", float);
  typedef Softmax<float> Softmaxf;
  NBLA_REGISTER_FUNCTION_IMPL(Softmax, Softmaxf, 0, "cpu", "default", int);
  typedef ELU<float> ELUf;
  NBLA_REGISTER_FUNCTION_IMPL(ELU, ELUf, 0, "cpu", "default", double);
  typedef SELU<float> SELUf;
  NBLA_REGISTER_FUNCTION_IMPL(SELU, SELUf, 0, "cpu", "default", double, double);
  typedef CReLU<float> CReLUf;
  NBLA_REGISTER_FUNCTION_IMPL(CReLU, CReLUf, 0, "cpu", "default", int);
  typedef CELU<float> CELUf;
  NBLA_REGISTER_FUNCTION_IMPL(CELU, CELUf, 0, "cpu", "default", double, int);
  typedef PReLU<float> PReLUf;
  NBLA_REGISTER_FUNCTION_IMPL(PReLU, PReLUf, 0, "cpu", "default", int);
  typedef BatchNormalization<float> BatchNormalizationf;
  NBLA_REGISTER_FUNCTION_IMPL(BatchNormalization, BatchNormalizationf, 0, "cpu", "default", const vector<int> &, float, float, bool);
  typedef MeanSubtraction<float> MeanSubtractionf;
  NBLA_REGISTER_FUNCTION_IMPL(MeanSubtraction, MeanSubtractionf, 0, "cpu", "default", int, bool);
  typedef Sum<float> Sumf;
  NBLA_REGISTER_FUNCTION_IMPL(Sum, Sumf, 0, "cpu", "default", const vector<int> &, bool);
  typedef Mean<float> Meanf;
  NBLA_REGISTER_FUNCTION_IMPL(Mean, Meanf, 0, "cpu", "default", const vector<int> &, bool);
  typedef Max<float> Maxf;
  NBLA_REGISTER_FUNCTION_IMPL(Max, Maxf, 0, "cpu", "default", const vector<int> &, bool);
  typedef Min<float> Minf;
  NBLA_REGISTER_FUNCTION_IMPL(Min, Minf, 0, "cpu", "default", const vector<int> &, bool);
  typedef Prod<float> Prodf;
  NBLA_REGISTER_FUNCTION_IMPL(Prod, Prodf, 0, "cpu", "default", const vector<int> &, bool);
  typedef ReduceSum<float> ReduceSumf;
  NBLA_REGISTER_FUNCTION_IMPL(ReduceSum, ReduceSumf, 0, "cpu", "default");
  typedef ReduceMean<float> ReduceMeanf;
  NBLA_REGISTER_FUNCTION_IMPL(ReduceMean, ReduceMeanf, 0, "cpu", "default");
  typedef Add2<float> Add2f;
  NBLA_REGISTER_FUNCTION_IMPL(Add2, Add2f, 0, "cpu", "default", bool);
  typedef BcAdd2<float> BcAdd2f;
  NBLA_REGISTER_FUNCTION_IMPL(BcAdd2, BcAdd2f, 0, "cpu", "default");
  typedef Sub2<float> Sub2f;
  NBLA_REGISTER_FUNCTION_IMPL(Sub2, Sub2f, 0, "cpu", "default");
  typedef Mul2<float> Mul2f;
  NBLA_REGISTER_FUNCTION_IMPL(Mul2, Mul2f, 0, "cpu", "default");
  typedef Div2<float> Div2f;
  NBLA_REGISTER_FUNCTION_IMPL(Div2, Div2f, 0, "cpu", "default");
  typedef Pow2<float> Pow2f;
  NBLA_REGISTER_FUNCTION_IMPL(Pow2, Pow2f, 0, "cpu", "default");
  typedef AddScalar<float> AddScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(AddScalar, AddScalarf, 0, "cpu", "default", double);
  typedef MulScalar<float> MulScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(MulScalar, MulScalarf, 0, "cpu", "default", double);
  typedef PowScalar<float> PowScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(PowScalar, PowScalarf, 0, "cpu", "default", double);
  typedef RSubScalar<float> RSubScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(RSubScalar, RSubScalarf, 0, "cpu", "default", double);
  typedef RDivScalar<float> RDivScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(RDivScalar, RDivScalarf, 0, "cpu", "default", double);
  typedef RPowScalar<float> RPowScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(RPowScalar, RPowScalarf, 0, "cpu", "default", double);
  typedef Sign<float> Signf;
  NBLA_REGISTER_FUNCTION_IMPL(Sign, Signf, 0, "cpu", "default", float);
  typedef Minimum2<float> Minimum2f;
  NBLA_REGISTER_FUNCTION_IMPL(Minimum2, Minimum2f, 0, "cpu", "default");
  typedef Maximum2<float> Maximum2f;
  NBLA_REGISTER_FUNCTION_IMPL(Maximum2, Maximum2f, 0, "cpu", "default");
  typedef MinimumScalar<float> MinimumScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(MinimumScalar, MinimumScalarf, 0, "cpu", "default", double);
  typedef MaximumScalar<float> MaximumScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(MaximumScalar, MaximumScalarf, 0, "cpu", "default", double);
  typedef LogicalAnd<float> LogicalAndf;
  NBLA_REGISTER_FUNCTION_IMPL(LogicalAnd, LogicalAndf, 0, "cpu", "default");
  typedef LogicalOr<float> LogicalOrf;
  NBLA_REGISTER_FUNCTION_IMPL(LogicalOr, LogicalOrf, 0, "cpu", "default");
  typedef LogicalXor<float> LogicalXorf;
  NBLA_REGISTER_FUNCTION_IMPL(LogicalXor, LogicalXorf, 0, "cpu", "default");
  typedef LogicalAndScalar<float> LogicalAndScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(LogicalAndScalar, LogicalAndScalarf, 0, "cpu", "default", bool);
  typedef LogicalOrScalar<float> LogicalOrScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(LogicalOrScalar, LogicalOrScalarf, 0, "cpu", "default", bool);
  typedef LogicalXorScalar<float> LogicalXorScalarf;
  NBLA_REGISTER_FUNCTION_IMPL(LogicalXorScalar, LogicalXorScalarf, 0, "cpu", "default", bool);
  typedef LogicalNot<float> LogicalNotf;
  NBLA_REGISTER_FUNCTION_IMPL(LogicalNot, LogicalNotf, 0, "cpu", "default");
  typedef Constant<float> Constantf;
  NBLA_REGISTER_FUNCTION_IMPL(Constant, Constantf, 0, "cpu", "default", float, const vector<int> &);
  typedef Abs<float> Absf;
  NBLA_REGISTER_FUNCTION_IMPL(Abs, Absf, 0, "cpu", "default");
  typedef Exp<float> Expf;
  NBLA_REGISTER_FUNCTION_IMPL(Exp, Expf, 0, "cpu", "default");
  typedef Log<float> Logf;
  NBLA_REGISTER_FUNCTION_IMPL(Log, Logf, 0, "cpu", "default");
  typedef Identity<float> Identityf;
  NBLA_REGISTER_FUNCTION_IMPL(Identity, Identityf, 0, "cpu", "default");
  typedef BatchMatmul<float> BatchMatmulf;
  NBLA_REGISTER_FUNCTION_IMPL(BatchMatmul, BatchMatmulf, 0, "cpu", "default", bool, bool);
  typedef Concatenate<float> Concatenatef;
  NBLA_REGISTER_FUNCTION_IMPL(Concatenate, Concatenatef, 0, "cpu", "default", int);
  typedef Split<float> Splitf;
  NBLA_REGISTER_FUNCTION_IMPL(Split, Splitf, 0, "cpu", "default", int);
  typedef Stack<float> Stackf;
  NBLA_REGISTER_FUNCTION_IMPL(Stack, Stackf, 0, "cpu", "default", int);
  typedef Slice<float> Slicef;
  NBLA_REGISTER_FUNCTION_IMPL(Slice, Slicef, 0, "cpu", "default", const vector<int> &, const vector<int> &, const vector<int> &);
  typedef Transpose<float> Transposef;
  NBLA_REGISTER_FUNCTION_IMPL(Transpose, Transposef, 0, "cpu", "default", const vector<int> &);
  typedef Broadcast<float> Broadcastf;
  NBLA_REGISTER_FUNCTION_IMPL(Broadcast, Broadcastf, 0, "cpu", "default", const vector<int> &);
  typedef OneHot<int, float> OneHotif;
  NBLA_REGISTER_FUNCTION_IMPL(OneHot, OneHotif, 0, "cpu", "default", const vector<int> &);
  typedef Flip<float> Flipf;
  NBLA_REGISTER_FUNCTION_IMPL(Flip, Flipf, 0, "cpu", "default", const vector<int> &);
  typedef Shift<float> Shiftf;
  NBLA_REGISTER_FUNCTION_IMPL(Shift, Shiftf, 0, "cpu", "default", const vector<int> &, const string &);
  typedef Reshape<float> Reshapef;
  NBLA_REGISTER_FUNCTION_IMPL(Reshape, Reshapef, 0, "cpu", "default", const vector<int> &);
  typedef MatrixDiag<float> MatrixDiagf;
  NBLA_REGISTER_FUNCTION_IMPL(MatrixDiag, MatrixDiagf, 0, "cpu", "default");
  typedef MatrixDiagPart<float> MatrixDiagPartf;
  NBLA_REGISTER_FUNCTION_IMPL(MatrixDiagPart, MatrixDiagPartf, 0, "cpu", "default");
  typedef Dropout<float> Dropoutf;
  NBLA_REGISTER_FUNCTION_IMPL(Dropout, Dropoutf, 0, "cpu", "default", double, int);
  typedef Rand<float> Randf;
  NBLA_REGISTER_FUNCTION_IMPL(Rand, Randf, 0, "cpu", "default", float, float, const vector<int> &, int);
  typedef Randint<int> Randinti;
  NBLA_REGISTER_FUNCTION_IMPL(Randint, Randinti, 0, "cpu", "default", int, int, const vector<int> &, int);
  typedef Randn<float> Randnf;
  NBLA_REGISTER_FUNCTION_IMPL(Randn, Randnf, 0, "cpu", "default", float, float, const vector<int> &, int);
  typedef RandomCrop<float> RandomCropf;
  NBLA_REGISTER_FUNCTION_IMPL(RandomCrop, RandomCropf, 0, "cpu", "default", const vector<int> &, int, int);
  typedef RandomFlip<float> RandomFlipf;
  NBLA_REGISTER_FUNCTION_IMPL(RandomFlip, RandomFlipf, 0, "cpu", "default", const vector<int> &, int, int);
  typedef RandomShift<float> RandomShiftf;
  NBLA_REGISTER_FUNCTION_IMPL(RandomShift, RandomShiftf, 0, "cpu", "default", const vector<int> &, const string &, int, int);
  typedef SigmoidCrossEntropy<float, int> SigmoidCrossEntropyfi;
  NBLA_REGISTER_FUNCTION_IMPL(SigmoidCrossEntropy, SigmoidCrossEntropyfi, 0, "cpu", "default");
  typedef BinaryCrossEntropy<float> BinaryCrossEntropyf;
  NBLA_REGISTER_FUNCTION_IMPL(BinaryCrossEntropy, BinaryCrossEntropyf, 0, "cpu", "default");
  typedef SoftmaxCrossEntropy<float, int> SoftmaxCrossEntropyfi;
  NBLA_REGISTER_FUNCTION_IMPL(SoftmaxCrossEntropy, SoftmaxCrossEntropyfi, 0, "cpu", "default", int);
  typedef CategoricalCrossEntropy<float, int> CategoricalCrossEntropyfi;
  NBLA_REGISTER_FUNCTION_IMPL(CategoricalCrossEntropy, CategoricalCrossEntropyfi, 0, "cpu", "default", int);
  typedef SquaredError<float> SquaredErrorf;
  NBLA_REGISTER_FUNCTION_IMPL(SquaredError, SquaredErrorf, 0, "cpu", "default");
  typedef AbsoluteError<float> AbsoluteErrorf;
  NBLA_REGISTER_FUNCTION_IMPL(AbsoluteError, AbsoluteErrorf, 0, "cpu", "default");
  typedef KLMultinomial<float> KLMultinomialf;
  NBLA_REGISTER_FUNCTION_IMPL(KLMultinomial, KLMultinomialf, 0, "cpu", "default", int);
  typedef Unlink<float> Unlinkf;
  NBLA_REGISTER_FUNCTION_IMPL(Unlink, Unlinkf, 0, "cpu", "default");
  typedef Sink<float> Sinkf;
  NBLA_REGISTER_FUNCTION_IMPL(Sink, Sinkf, 0, "cpu", "default", bool);

  // Solver registration
  typedef Adadelta<float> Adadeltaf;
  NBLA_REGISTER_SOLVER_IMPL(Adadelta, Adadeltaf, 0, "cpu", "default", float, float,
    float);
  typedef Adagrad<float> Adagradf;
  NBLA_REGISTER_SOLVER_IMPL(Adagrad, Adagradf, 0, "cpu", "default", float, float);
  typedef Adam<float> Adamf;
  NBLA_REGISTER_SOLVER_IMPL(Adam, Adamf, 0, "cpu", "default", float, float,
    float, float);
  typedef Adamax<float> Adamaxf;
  NBLA_REGISTER_SOLVER_IMPL(Adamax, Adamaxf, 0, "cpu", "default", float, float,
    float, float);
  typedef Momentum<float> Momentumf;
  NBLA_REGISTER_SOLVER_IMPL(Momentum, Momentumf, 0, "cpu", "default", float, float);
  typedef Nesterov<float> Nesterovf;
  NBLA_REGISTER_SOLVER_IMPL(Nesterov, Nesterovf, 0, "cpu", "default", float, float);
  typedef RMSprop<float> RMSpropf;
  NBLA_REGISTER_SOLVER_IMPL(RMSprop, RMSpropf, 0, "cpu", "default", float, float,
    float);
  typedef Sgd<float> Sgdf;
  NBLA_REGISTER_SOLVER_IMPL(Sgd, Sgdf, 0, "cpu", "default", float);

  is_initialized = true;
}

void clear_cpu_memory_cache() {
  SingletonManager::get<Cpu>()->memcache().clear();
}

}
